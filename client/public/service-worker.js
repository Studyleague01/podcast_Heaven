/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.

importScripts(
  'https://storage.googleapis.com/workbox-cdn/releases/6.5.4/workbox-sw.js'
);

// Use workbox from importScripts
const { clientsClaim } = workbox.core;
const { ExpirationPlugin } = workbox.expiration;
const { precacheAndRoute, createHandlerBoundToURL } = workbox.precaching;
const { registerRoute } = workbox.routing;
const { StaleWhileRevalidate, CacheFirst, NetworkFirst } = workbox.strategies;

// Immediately take control of the page to avoid waiting for reload
clientsClaim();
self.skipWaiting();

// Define a manual manifest if __WB_MANIFEST is not available
// Define core assets to cache
const CORE_ASSETS = [
  { url: '/', revision: '1' },
  { url: '/index.html', revision: '1' },
  { url: '/manifest.json', revision: '1' },
  { url: '/favicon.ico', revision: '1' },
  { url: '/logo192.png', revision: '1' },
  { url: '/logo512.png', revision: '1' },
  { url: '/maskable_icon.png', revision: '1' },
  { url: '/assets/index.css', revision: '1' },
  { url: '/assets/index.js', revision: '1' },
];

// Add current path-based assets
const pathPrefix = self.location.pathname.replace(/\/service-worker\.js$/, '');
const BASE_MANIFEST = CORE_ASSETS.map(asset => ({
  url: asset.url.startsWith('/') ? `${pathPrefix}${asset.url}` : asset.url,
  revision: asset.revision
}));

// Precache all the assets generated by your build process
// Try to use __WB_MANIFEST if available, otherwise use our base manifest
console.log('Precaching assets with service worker');
precacheAndRoute(self.__WB_MANIFEST || BASE_MANIFEST);

// Handle assets URLs 
registerRoute(
  // Match all URLs that end with a file extension
  ({ request }) => request.destination === 'style' || 
                  request.destination === 'script' ||
                  request.destination === 'font',
  new StaleWhileRevalidate({
    cacheName: 'assets-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// Cache images separately with a cache-first strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// Set up navigation routes to always go through index.html
// This is needed for SPA with client-side routing
const indexFallbackHandler = createHandlerBoundToURL('/index.html');
registerRoute(
  // Check for all navigation requests:
  // - Standard routes like /auth, /search, etc.
  // - Deep-linked routes that should be handled client-side
  ({ request, url }) => {
    // Check if this is a navigation request
    if (request.mode !== 'navigate') {
      return false;
    }
    
    // Define client-side routes to capture
    const clientRoutes = [
      // Basic routes
      /^\/?$/,              // home
      /^\/auth\/?$/,        // authentication
      /^\/create\/?$/,      // create page
      
      // Parameterized routes
      /^\/search\/[^/]+\/?$/,     // search results
      /^\/podcast\/[^/]+\/?$/,    // podcast details
      /^\/channel\/[^/]+\/?$/     // channel view
    ];
    
    // Check if the current URL path matches any of our client routes
    const path = new URL(url).pathname;
    return clientRoutes.some(route => route.test(path));
  },
  // Use a network-first strategy for HTML pages with fallback to index.html
  new NetworkFirst({
    cacheName: 'pages-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
      }),
    ],
    networkTimeoutSeconds: 5, // Timeout if network takes too long
    matchOptions: {
      ignoreSearch: true     // Ignore query parameters
    },
    // Fall back to the cached index.html if network request fails
    // This ensures client-side routing works offline
    fallbackToNetwork: false
  })
);

// For any other navigation requests not matched by the above routes,
// fall back to index.html to allow client-side routing to handle it
registerRoute(
  ({ request }) => request.mode === 'navigate',
  indexFallbackHandler
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Handle offline fallback when network is unavailable
self.addEventListener('fetch', (event) => {
  // Only handle navigate requests (page loads)
  if (event.request.mode === 'navigate') {
    event.respondWith(
      fetch(event.request)
        .catch(() => {
          // If fetch fails (offline), return the cached index page
          return caches.match('/index.html')
            .then(response => {
              if (response) {
                return response;
              }
              // If we can't find /index.html, try with the path prefix
              const pathPrefix = self.location.pathname.replace(/\/service-worker\.js$/, '');
              return caches.match(`${pathPrefix}/index.html`) || caches.match('/');
            });
        })
    );
  }
});